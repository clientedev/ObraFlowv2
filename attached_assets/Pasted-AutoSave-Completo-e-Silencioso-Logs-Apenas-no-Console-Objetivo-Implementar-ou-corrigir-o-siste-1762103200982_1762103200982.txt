AutoSave Completo e Silencioso (Logs Apenas no Console)

Objetivo:
Implementar (ou corrigir) o sistema de salvamento autom√°tico do relat√≥rio de obras, garantindo que todas as informa√ß√µes (inclusive imagens e checklist) sejam armazenadas corretamente no backend e recuperadas depois, sem qualquer feedback visual, apenas com logs no console.

‚öôÔ∏è Problema Atual

O AutoSave dispara requisi√ß√µes POST /api/relatorios/autosave que retornam HTTP 400 (Bad Request) com { "error": "Erro desconhecido" }.

O payload enviado cont√©m campos ausentes, nulos ou com tipo incorreto.

Fun√ß√µes como getChecklistData() n√£o est√£o implementadas corretamente, quebrando o fluxo de salvamento.

Nenhum dado √© realmente persistido (nem imagens, nem texto, nem campos b√°sicos).

üéØ Meta T√©cnica

O AutoSave deve:

Salvar todos os campos e todas as imagens de forma incremental e autom√°tica.

Enviar dados formatados corretamente ao backend.

Funcionar silenciosamente (sem notifica√ß√µes gr√°ficas).

Registrar no console todas as etapas: coleta, envio, sucesso e falha.

Garantir persist√™ncia ‚Äî se o usu√°rio sair da p√°gina, poder√° continuar o relat√≥rio depois exatamente de onde parou.

üß© Implementa√ß√£o Detalhada
1. Frontend ‚Äî reports_autosave.js
‚û§ Coleta completa dos dados

Corrigir a fun√ß√£o collectFormData() para incluir todos os campos e imagens, normalizando os dados antes de enviar:

collectFormData() {
  const data = {
    id: window.currentReportId || null,
    titulo: document.querySelector("#titulo_relatorio")?.value || null,
    numero: document.querySelector("#numero_relatorio")?.value || null,
    data_relatorio: document.querySelector("#data_relatorio")?.value || null,
    projeto_id: document.querySelector("#projeto_id")?.value || null,
    observacoes_finais: document.querySelector("#observacoes")?.value || null,
    lembrete_proxima_visita: document.querySelector("#lembrete")?.value || null,
    categoria: document.querySelector("#categoria")?.value || null,
    local: document.querySelector("#local")?.value || null,
    descricao: document.querySelector("#descricao")?.value || null,
    checklist_data: this.getChecklistData(),
    fotos: this.getImageData(),
  };
  
  console.log("üì¶ AutoSave - Dados coletados:", data);
  return data;
}

‚û§ Fun√ß√£o getChecklistData()

Implementar corretamente para retornar os itens com status e observa√ß√µes:

getChecklistData() {
  return Array.from(document.querySelectorAll(".checklist-item")).map(item => ({
    nome: item.querySelector("label")?.textContent?.trim() || "",
    status: item.querySelector("input[type='checkbox']")?.checked || false,
    observacao: item.querySelector("textarea")?.value || ""
  }));
}

‚û§ Fun√ß√£o getImageData()

Coletar informa√ß√µes das imagens anexadas:

getImageData() {
  const images = window.attachedImages || [];
  return images.map(img => ({
    nome: img.name || null,
    legenda: img.caption || null,
    categoria: img.category || null,
    local: img.location || null
  }));
}

‚û§ Envio ao backend (performSave)

Corrigir o m√©todo principal do autosave para enviar o payload completo, tratar erros e registrar logs apenas no console:

async performSave() {
  const payload = this.collectFormData();

  try {
    const response = await fetch("/api/relatorios/autosave", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      console.error("‚ùå AutoSave erro HTTP:", response.status, err);
      throw new Error(err.detail || "Falha no autosave");
    }

    const result = await response.json();
    console.log("‚úÖ AutoSave conclu√≠do com sucesso:", result);
  } catch (error) {
    console.warn("‚ö†Ô∏è AutoSave falhou:", error.message);
    console.info("üíæ Salvando temporariamente no localStorage...");
    localStorage.setItem("autosave_draft", JSON.stringify(payload));
  }
}

‚û§ Agendamento autom√°tico de salvamento

Adicionar debounce controlado:

startAutoSave() {
  let timer;
  const saveHandler = () => {
    clearTimeout(timer);
    timer = setTimeout(() => this.performSave(), 2000);
  };
  
  document.querySelectorAll("input, textarea, select").forEach(el => {
    el.addEventListener("input", saveHandler);
    el.addEventListener("change", saveHandler);
  });

  console.log("üïí AutoSave ativado para relat√≥rio atual.");
}

2. Backend ‚Äî FastAPI (/api/relatorios/autosave)

Corrigir o endpoint para aceitar payloads parciais e validar campos dinamicamente:

@router.post("/api/relatorios/autosave")
async def autosave_relatorio(payload: dict, db: Session = Depends(get_db)):
    try:
        relatorio_id = payload.get("id")
        if relatorio_id:
            relatorio = db.query(Relatorio).filter_by(id=relatorio_id).first()
            if not relatorio:
                raise HTTPException(status_code=404, detail="Relat√≥rio n√£o encontrado")
        else:
            relatorio = Relatorio()
            db.add(relatorio)

        # Atualiza apenas os campos enviados
        for key, value in payload.items():
            if hasattr(relatorio, key):
                setattr(relatorio, key, value)

        db.commit()
        db.refresh(relatorio)
        print("‚úÖ AutoSave registrado:", relatorio.id)
        return {"status": "ok", "id": relatorio.id}

    except Exception as e:
        db.rollback()
        print("‚ùå Erro no autosave:", str(e))
        raise HTTPException(status_code=400, detail=str(e))

3. Banco de Dados / Alembic

Se faltarem campos referenciados no payload (descricao, lembrete_proxima_visita, categoria, local, etc.), gerar uma migra√ß√£o autom√°tica:

alembic revision -m "Ajuste de campos para autosave completo" --autogenerate
alembic upgrade head

üîç Logs Esperados no Console

Ao detectar mudan√ßas:

üì¶ AutoSave - Dados coletados: { titulo: "Relat√≥rio...", data_relatorio: "2025-11-02", ... }


Ao salvar:

‚úÖ AutoSave conclu√≠do com sucesso: { id: 177, status: "ok" }


Em falha:

‚ö†Ô∏è AutoSave falhou: Falha no autosave
üíæ Salvando temporariamente no localStorage...

üß± Resultado Esperado

Todos os campos (inclusive imagens e checklist) ser√£o salvos automaticamente no backend.

Nenhum erro 400 ser√° exibido.

AutoSave rodar√° de forma cont√≠nua, silenciosa e confi√°vel.

Em caso de falha de rede, os dados ficam salvos no localStorage at√© reconex√£o.

Logs de diagn√≥stico completos dispon√≠veis apenas no console (sem impacto na UI).