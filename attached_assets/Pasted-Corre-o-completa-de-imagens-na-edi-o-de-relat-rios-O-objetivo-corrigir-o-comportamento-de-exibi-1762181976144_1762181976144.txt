Corre√ß√£o completa de imagens na edi√ß√£o de relat√≥rios

O objetivo √© corrigir o comportamento de exibi√ß√£o e salvamento das imagens associadas a um relat√≥rio ao editar, garantindo que:

As imagens j√° existentes sejam carregadas e exibidas automaticamente no mesmo layout e estrutura do template usado ao adicionar novas imagens.

Ao salvar a edi√ß√£o, as imagens sejam mantidas corretamente no banco (sem duplicar nem perder).

Se o usu√°rio adicionar novas imagens, elas se somem √†s existentes.

Se o usu√°rio excluir alguma imagem, ela seja removida corretamente do relat√≥rio e do diret√≥rio de m√≠dia.

O processo de sobrescrita do relat√≥rio funcione 100%, sem criar novo registro duplicado.

üîç 1Ô∏è‚É£ ‚Äî Diagn√≥stico t√©cnico

Atualmente, na rota /reports/<id>/editarrel (ou equivalente report_edit_complete):

As imagens n√£o s√£o renderizadas corretamente no template ‚Äî aparecem vazias ou n√£o aparecem.

Isso ocorre porque:

O backend n√£o envia o campo de imagens em formato process√°vel (list com URLs v√°lidas).

O template de edi√ß√£o (form_complete.html ou similar) n√£o reusa o mesmo trecho usado no upload.

O salvamento sobrescreve o relat√≥rio, mas n√£o vincula corretamente as imagens j√° existentes.

‚öôÔ∏è 2Ô∏è‚É£ ‚Äî Corre√ß√£o no backend

Garanta que o backend envie as imagens existentes da mesma forma que o template de cria√ß√£o espera.

Na fun√ß√£o que renderiza o formul√°rio de edi√ß√£o (report_edit_complete), ajuste:

def report_edit_complete(report_id):
    relatorio = db.session.query(Relatorio).get(report_id)
    if not relatorio:
        abort(404)

    imagens = []
    for img in relatorio.imagens_relatorio:  # nome do relacionamento
        imagens.append({
            "id": img.id,
            "url": url_for('static', filename=f'uploads/{img.caminho}', _external=False),
            "nome": img.caminho
        })

    return render_template(
        'form_complete.html',
        relatorio=relatorio,
        imagens=imagens,
        modo_edicao=True
    )


‚úÖ Explica√ß√£o:

Isso garante que a lista imagens seja entregue ao template com URLs prontas para exibi√ß√£o.

Use url_for('static', filename=...) ou a rota de m√≠dia usada no app.

modo_edicao=True ser√° usado no template para reexibir a galeria.

üñ•Ô∏è 3Ô∏è‚É£ ‚Äî Corre√ß√£o no template HTML (form_complete.html)

No bloco de upload de imagens, garanta que:

As imagens existentes sejam renderizadas logo ao carregar.

O mesmo HTML de preview usado ap√≥s upload seja reaproveitado.

Adicione no final do script:

<script>
document.addEventListener("DOMContentLoaded", () => {
  const modoEdicao = {{ 'true' if modo_edicao else 'false' }};
  if (modoEdicao && {{ imagens|length if imagens else 0 }} > 0) {
    const imagens = {{ imagens|tojson }};
    const container = document.querySelector('#preview-container');

    imagens.forEach(img => {
      const div = document.createElement("div");
      div.classList.add("preview-item");
      div.innerHTML = `
        <img src="${img.url}" alt="${img.nome}" class="preview-img">
        <button type="button" class="btn btn-danger btn-sm remove-image" data-id="${img.id}">Excluir</button>
      `;
      container.appendChild(div);
    });
  }
});
</script>


‚úÖ Explica√ß√£o:

Esse trecho injeta dinamicamente as imagens existentes no mesmo container usado pelo script de upload.

Assim, o comportamento visual ser√° id√™ntico ao de adicionar uma imagem nova.

üíæ 4Ô∏è‚É£ ‚Äî Corre√ß√£o no salvamento (update)

Na fun√ß√£o que trata o POST da edi√ß√£o:

def atualizar_relatorio(report_id):
    relatorio = db.session.query(Relatorio).get(report_id)
    if not relatorio:
        abort(404)

    relatorio.titulo = request.form['titulo']
    relatorio.descricao = request.form['descricao']
    # Outros campos...

    # 1Ô∏è‚É£ Preserva imagens existentes
    imagens_existentes_ids = request.form.getlist('imagens_existentes')
    relatorio.imagens_relatorio = [
        img for img in relatorio.imagens_relatorio if str(img.id) in imagens_existentes_ids
    ]

    # 2Ô∏è‚É£ Adiciona novas imagens
    arquivos = request.files.getlist('imagens')
    for arquivo in arquivos:
        if arquivo.filename:
            nome_arquivo = secure_filename(arquivo.filename)
            caminho = os.path.join(app.config['UPLOAD_FOLDER'], nome_arquivo)
            arquivo.save(caminho)

            nova_imagem = ImagemRelatorio(caminho=nome_arquivo, relatorio_id=relatorio.id)
            db.session.add(nova_imagem)

    db.session.commit()
    flash('Relat√≥rio atualizado com sucesso!', 'success')
    return redirect(url_for('listar_relatorios'))


‚úÖ Explica√ß√£o:

Garante que:

As imagens j√° existentes permane√ßam vinculadas.

As novas sejam adicionadas corretamente.

O relat√≥rio seja sobrescrito, n√£o recriado.

As imagens removidas sejam de fato exclu√≠das.

üßπ 5Ô∏è‚É£ ‚Äî Excluir imagem ao clicar no bot√£o ‚ÄúExcluir‚Äù

Adicione no JS:

<script>
document.addEventListener("click", e => {
  if (e.target.classList.contains("remove-image")) {
    const id = e.target.dataset.id;
    e.target.closest(".preview-item").remove();
    // Remove tamb√©m o hidden input correspondente, se houver
    const hidden = document.querySelector(`input[name="imagens_existentes"][value="${id}"]`);
    if (hidden) hidden.remove();
  }
});
</script>


E no template, ao renderizar imagens existentes, adicione:

<input type="hidden" name="imagens_existentes" value="{{ img.id }}">


Assim, o backend saber√° quais imagens devem ser mantidas.

üßæ 6Ô∏è‚É£ ‚Äî Testes finais obrigat√≥rios
Cen√°rio	Resultado esperado
Abrir relat√≥rio existente	Todas as imagens aparecem no preview exatamente como ao adicionar
Adicionar nova imagem	Ela aparece imediatamente no preview e √© salva junto
Remover imagem	Ela desaparece do preview e n√£o √© salva no banco
Salvar relat√≥rio	Atualiza corretamente o mesmo registro
Reabrir relat√≥rio	As imagens mantidas e novas aparecem corretamente
‚úÖ Resumo do que o prompt deve executar

Corrigir o envio de imagens no backend (report_edit_complete).

Renderizar imagens existentes no mesmo HTML do upload.

Preservar imagens antigas e adicionar novas sem duplicar relat√≥rio.

Permitir exclus√£o de imagens na edi√ß√£o.

Confirmar salvamento e reexibi√ß√£o corretos.