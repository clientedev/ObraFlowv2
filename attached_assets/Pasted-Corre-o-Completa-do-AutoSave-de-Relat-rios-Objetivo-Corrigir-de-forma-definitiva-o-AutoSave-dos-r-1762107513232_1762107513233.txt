Corre√ß√£o Completa do AutoSave de Relat√≥rios

Objetivo:
Corrigir de forma definitiva o AutoSave dos relat√≥rios no sistema, garantindo que todos os dados (campos, checklist, acompanhantes, lembrete e imagens) sejam coletados, validados e salvos corretamente no backend FastAPI integrado ao banco PostgreSQL (Railway).
O sistema deve funcionar sem falhas de comunica√ß√£o, sem depend√™ncia de tabelas externas como legendas_predefinidas e sem qualquer impacto visual no frontend (apenas logs t√©cnicos no console).

‚öôÔ∏è Diagn√≥stico do Problema Atual

O log mostra:

üìã AutoSave - Checklist: 6 itens coletados
üì∏ AutoSave - Imagens: 0 imagens coletadas
üë• AutoSave - Acompanhantes: 1 pessoas
üì¶ AutoSave - Dados coletados: { titulo: 'Relat√≥rio de visita TESTE', numero: 'REL-0002', projeto_id: '34', conteudo: null, fotos: null, ... }
‚ùå AutoSave erro HTTP 400 {}
‚ö†Ô∏è AutoSave falhou: Falha no autosave


üëâ O AutoSave coleta corretamente os dados do frontend,
mas falha ao enviar para o backend porque:

Campos como fotos e conteudo est√£o com null (PostgreSQL n√£o aceita o tipo esperado).

O backend exige tipos espec√≠ficos (arrays, JSON ou texto), e o envio incorreto causa o erro 400.

O endpoint /api/relatorios/autosave n√£o trata updates parciais corretamente.

üéØ Meta T√©cnica

Tornar o AutoSave totalmente resiliente ‚Äî salvar tudo (inclusive imagens e checklist).

Permitir atualiza√ß√£o incremental (salvar campos parciais sem sobrescrever os outros).

Garantir compatibilidade total com o banco Railway PostgreSQL.

Fazer logs t√©cnicos apenas no console (sem avisos visuais).

Ignorar completamente qualquer rela√ß√£o com a tabela legendas_predefinidas ‚Äî ela √© independente.

üîß IMPLEMENTA√á√ÉO COMPLETA
üîπ 1. FRONTEND ‚Äî reports_autosave.js
‚úÖ Coleta de dados completa
collectFormData() {
  try {
    const data = {
      id: window.currentReportId || null,
      titulo: document.querySelector("#titulo_relatorio")?.value?.trim() || null,
      numero: document.querySelector("#numero_relatorio")?.value?.trim() || null,
      data_relatorio: document.querySelector("#data_relatorio")?.value || null,
      projeto_id: document.querySelector("#projeto_id")?.value || null,
      observacoes_finais: document.querySelector("#observacoes")?.value?.trim() || null,
      lembrete_proxima_visita: document.querySelector("#lembrete")?.value?.trim() || null,
      conteudo: this.collectRichTextContent() || "",
      checklist_data: this.getChecklistData(),
      acompanhantes: this.getAcompanhantesData(),
      fotos: this.getImageData(),
    };

    console.log("üì¶ AutoSave - Dados coletados:", data);
    return data;
  } catch (err) {
    console.error("‚ùå AutoSave: erro ao coletar dados do formul√°rio:", err);
    return {};
  }
}

‚úÖ Fun√ß√µes auxiliares
getChecklistData() {
  return Array.from(document.querySelectorAll(".checklist-item")).map(item => ({
    nome: item.querySelector("label")?.textContent?.trim() || "",
    status: item.querySelector("input[type='checkbox']")?.checked || false,
    observacao: item.querySelector("textarea")?.value?.trim() || ""
  }));
}

getAcompanhantesData() {
  return window.acompanhantes || [];
}

getImageData() {
  const imgs = window.attachedImages || [];
  return imgs.map(img => ({
    nome: img.name || null,
    categoria: img.category || null,
    local: img.location || null,
    legenda: img.caption || null
  }));
}

collectRichTextContent() {
  const editor = document.querySelector(".ql-editor");
  return editor ? editor.innerHTML.trim() : "";
}

‚úÖ Envio seguro com tratamento de erro e convers√£o de null
async performSave() {
  const payload = this.collectFormData();

  // Converte campos null para valores aceitos
  Object.keys(payload).forEach(key => {
    if (payload[key] === null) payload[key] = "";
  });

  try {
    const response = await fetch("/api/relatorios/autosave", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      console.error(`‚ùå AutoSave erro HTTP: ${response.status}`, err);
      throw new Error(err.detail || "Falha no autosave");
    }

    const result = await response.json();
    console.log("‚úÖ AutoSave conclu√≠do:", result);
  } catch (error) {
    console.warn("‚ö†Ô∏è AutoSave falhou:", error.message);
    console.info("üíæ Salvando localmente no localStorage...");
    localStorage.setItem("autosave_draft", JSON.stringify(payload));
  }
}

‚úÖ Ativa√ß√£o autom√°tica (sem interface)
startAutoSave() {
  let timer;
  const handler = () => {
    clearTimeout(timer);
    timer = setTimeout(() => this.performSave(), 3000);
  };

  document.querySelectorAll("input, textarea, select").forEach(el => {
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  console.log("üïí AutoSave ativado (Railway DB sync habilitado)");
}

üîπ 2. BACKEND ‚Äî /api/relatorios/autosave
‚úÖ Corrigir endpoint para aceitar atualiza√ß√µes parciais e JSON flex√≠vel
@router.post("/api/relatorios/autosave")
async def autosave_relatorio(payload: dict, db: Session = Depends(get_db)):
    """
    Atualiza ou cria um relat√≥rio parcialmente,
    garantindo compatibilidade com o PostgreSQL (Railway).
    """
    try:
        relatorio_id = payload.get("id")
        if relatorio_id:
            relatorio = db.query(Relatorio).filter_by(id=relatorio_id).first()
            if not relatorio:
                raise HTTPException(status_code=404, detail="Relat√≥rio n√£o encontrado")
        else:
            relatorio = Relatorio()
            db.add(relatorio)

        # Atualiza somente os campos existentes no modelo
        for key, value in payload.items():
            if hasattr(relatorio, key):
                # Evita erro de tipo JSON/nulo no PostgreSQL
                if value in [None, "null", ""]:
                    setattr(relatorio, key, None)
                elif key in ["checklist_data", "fotos", "acompanhantes"]:
                    setattr(relatorio, key, json.dumps(value))
                else:
                    setattr(relatorio, key, value)

        db.commit()
        db.refresh(relatorio)

        print(f"‚úÖ AutoSave atualizado no Railway para relat√≥rio ID={relatorio.id}")
        return {"status": "ok", "id": relatorio.id}

    except Exception as e:
        db.rollback()
        print("‚ùå AutoSave error:", str(e))
        raise HTTPException(status_code=400, detail=f"Erro ao salvar: {e}")

üîπ 3. BANCO DE DADOS (RAILWAY POSTGRES)

Confirmar a estrutura m√≠nima:

ALTER TABLE relatorios
ADD COLUMN IF NOT EXISTS conteudo TEXT,
ADD COLUMN IF NOT EXISTS checklist_data JSONB,
ADD COLUMN IF NOT EXISTS fotos JSONB,
ADD COLUMN IF NOT EXISTS acompanhantes JSONB,
ADD COLUMN IF NOT EXISTS lembrete_proxima_visita TEXT,
ADD COLUMN IF NOT EXISTS observacoes_finais TEXT;


‚úÖ Aten√ß√£o:

A tabela legendas_predefinidas j√° existe no PostgreSQL do Railway e n√£o tem rela√ß√£o com o AutoSave.

Nenhuma altera√ß√£o ser√° feita nela.

üßæ Logs esperados no console (sem interface visual)

Sucesso:

üì¶ AutoSave - Dados coletados: {titulo: "Relat√≥rio de visita TESTE", ...}
‚úÖ AutoSave conclu√≠do: {status: "ok", id: 182}


Falha (modo offline):

‚ùå AutoSave erro HTTP: 400 {detail: "..."}
üíæ Salvando localmente no localStorage...

‚úÖ RESULTADO FINAL

AutoSave 100% funcional e compat√≠vel com o PostgreSQL no Railway.

Nenhum erro 400.

Todos os campos (texto, checklist, lembrete, imagens, acompanhantes) salvos automaticamente.

Atualiza√ß√£o incremental (sem sobrescrever dados existentes).

Logs exclusivamente no console (sem exibi√ß√£o visual).

Independente da tabela legendas_predefinidas.