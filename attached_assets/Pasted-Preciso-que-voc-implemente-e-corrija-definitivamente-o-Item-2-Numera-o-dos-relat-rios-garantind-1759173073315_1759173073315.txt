Preciso que voc√™ implemente e corrija definitivamente o Item 2 ‚Äì Numera√ß√£o dos relat√≥rios, garantindo que:

Cada obra (projeto_id) tenha sua pr√≥pria sequ√™ncia de relat√≥rios.

Exemplo:

Projeto Y ‚Üí REL-0001, REL-0002, REL-0003...

Projeto Z ‚Üí REL-0001, REL-0002, REL-0003...

Ou seja, a contagem sempre recome√ßa do 1 para cada projeto.

Estrutura da tabela relatorios j√° existente:

id, numero, titulo, projeto_id, visita_id, autor_id, aprovador_id,
data_relatorio, data_aprovacao, conteudo, checklist_data, status,
comentario_aprovacao, created_at, updated_at, numero_projeto


A coluna numero_projeto j√° existe mas est√° vazia (NULL).

A coluna numero hoje gera sequ√™ncia global (mistura relat√≥rios de diferentes projetos).

O que voc√™ deve fazer:
üîπ 1. Corrigir retroativamente os relat√≥rios existentes

Usar a coluna created_at para ordenar os relat√≥rios dentro de cada projeto_id.

Preencher numero_projeto com a sequ√™ncia correta (1, 2, 3‚Ä¶).

Atualizar tamb√©m a coluna numero para refletir a sequ√™ncia dentro do projeto (REL-000X).

SQL a ser usado dentro de uma migra√ß√£o Alembic:

from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import text

revision = 'xxxxxx_fix_numero_relatorio_por_projeto'
down_revision = 'ULTIMO_REVISION_EXISTENTE'
branch_labels = None
depends_on = None

def upgrade():
    conn = op.get_bind()

    update_sql = """
    WITH ranked AS (
        SELECT id,
               projeto_id,
               ROW_NUMBER() OVER (PARTITION BY projeto_id ORDER BY created_at ASC) AS seq
        FROM relatorios
    )
    UPDATE relatorios r
    SET numero_projeto = ranked.seq,
        numero = 'REL-' || LPAD(ranked.seq::text, 4, '0')
    FROM ranked
    WHERE r.id = ranked.id;
    """
    conn.execute(text(update_sql))

def downgrade():
    conn = op.get_bind()
    conn.execute(text("UPDATE relatorios SET numero_projeto = NULL;"))

üîπ 2. Corrigir a cria√ß√£o de novos relat√≥rios (routes.py)

Na rota de cria√ß√£o de relat√≥rios, substituir a l√≥gica atual por:

ultimo_numero = db.session.query(
    db.func.max(Relatorio.numero_projeto)
).filter_by(projeto_id=projeto_id).scalar()

if ultimo_numero is None:
    proximo_numero = 1
else:
    proximo_numero = ultimo_numero + 1

relatorio.numero_projeto = proximo_numero
relatorio.numero = f"REL-{proximo_numero:04d}"


Assim, cada projeto ter√° sua pr√≥pria contagem.

üîπ 3. Garantir compatibilidade com relat√≥rios antigos

Depois da migra√ß√£o, todos os relat√≥rios existentes ter√£o numero_projeto preenchido corretamente.

Novos relat√≥rios v√£o continuar a sequ√™ncia correta por projeto.

PDFs, templates e listagens devem exibir relatorio.numero.

‚úÖ Requisitos finais

Criar um arquivo Alembic novo para atualizar o banco.

Validar que /reports exibe relat√≥rios numerados corretamente por obra.

Testar criando relat√≥rios em diferentes projetos: cada um deve iniciar em REL-0001.

Banco: PostgreSQL no Railway.

üìå Resumo para desenvolvedor:
A regra √© simples: relat√≥rios s√£o numerados sempre por obra/projeto.

Primeiro relat√≥rio da obra X ‚Üí REL-0001.

Segundo relat√≥rio da obra X ‚Üí REL-0002.

Se for obra Y, come√ßa do REL-0001 de novo.

üëâ Quer que eu tamb√©m monte um comando SQL puro (s