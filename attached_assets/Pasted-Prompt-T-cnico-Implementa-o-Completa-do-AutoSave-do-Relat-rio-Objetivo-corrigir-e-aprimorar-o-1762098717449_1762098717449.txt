Prompt T√©cnico ‚Äî Implementa√ß√£o Completa do AutoSave do Relat√≥rio

Objetivo: corrigir e aprimorar o comportamento do salvamento autom√°tico (AutoSave) do m√≥dulo de relat√≥rios, garantindo que todos os campos ‚Äî incluindo textos, sele√ß√µes, lembretes, observa√ß√µes, anexos e imagens ‚Äî sejam salvos automaticamente e restaurados corretamente ao retomar a edi√ß√£o, sem perda de dados ou inconsist√™ncias no banco.

üß† Escopo e Requisitos Funcionais

AutoSave deve funcionar em tempo real e de forma incremental, salvando periodicamente (ex: a cada 5 segundos) qualquer modifica√ß√£o feita pelo usu√°rio, sem a necessidade de clicar em ‚ÄúConcluir‚Äù.

Todos os campos do relat√≥rio devem ser inclu√≠dos no processo autom√°tico de salvamento:

t√≠tulo, n√∫mero, categoria, local, lembrete, observa√ß√µes, status, conte√∫do, checklist, acompanhantes, etc.;

imagens anexadas (novas, removidas ou editadas);

metadados das imagens: categoria, local, legenda.

O AutoSave deve ser resiliente: se o relat√≥rio ainda n√£o existir no banco, criar automaticamente um novo registro e retornar o id para continuidade do salvamento.

Caso a conex√£o ou backend falhem, o sistema deve tentar novamente ao detectar reconex√£o, sem perda de progresso.

Toda atualiza√ß√£o deve refletir tamb√©m no campo updated_at da tabela relatorios.

üß© Backend ‚Äì Implementa√ß√£o Recomendada (FastAPI + SQLAlchemy)

Crie (ou atualize) o endpoint de AutoSave no backend:

# routes/relatorios.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from datetime import datetime
from models import Relatorio, FotoRelatorio
from database import get_db

router = APIRouter()

@router.post("/api/relatorios/autosave")
def autosave_relatorio(data: dict, db: Session = Depends(get_db)):
    try:
        relatorio_id = data.get("id")

        # 1Ô∏è‚É£ Se o relat√≥rio n√£o existe, cria um novo automaticamente
        if not relatorio_id:
            novo = Relatorio(
                titulo=data.get("titulo"),
                numero=data.get("numero"),
                categoria=data.get("categoria"),
                local=data.get("local"),
                observacoes_finais=data.get("observacoes_finais"),
                lembrete_proxima_visita=data.get("lembrete_proxima_visita"),
                conteudo=data.get("conteudo"),
                status=data.get("status", "Em preenchimento"),
                criado_por=data.get("criado_por"),
                criado_em=datetime.utcnow()
            )
            db.add(novo)
            db.commit()
            db.refresh(novo)
            relatorio_id = novo.id

        # 2Ô∏è‚É£ Atualiza os campos existentes do relat√≥rio
        relatorio = db.query(Relatorio).filter(Relatorio.id == relatorio_id).first()
        if not relatorio:
            raise HTTPException(status_code=404, detail="Relat√≥rio n√£o encontrado")

        for campo, valor in data.items():
            if campo not in ["id", "fotos"] and hasattr(relatorio, campo):
                setattr(relatorio, campo, valor)

        relatorio.updated_at = datetime.utcnow()

        # 3Ô∏è‚É£ Atualiza as imagens associadas
        if "fotos" in data:
            imagens = data["fotos"]
            for img in imagens:
                # Deletar imagem marcada para remo√ß√£o
                if img.get("deletar"):
                    db.query(FotoRelatorio).filter(FotoRelatorio.id == img["id"]).delete()
                    continue

                # Adicionar nova imagem
                if not img.get("id"):
                    nova_foto = FotoRelatorio(
                        relatorio_id=relatorio_id,
                        caminho=img["caminho"],
                        categoria=img.get("categoria"),
                        local=img.get("local"),
                        legenda=img.get("legenda")
                    )
                    db.add(nova_foto)

                # Atualizar imagem existente
                else:
                    existente = db.query(FotoRelatorio).filter(FotoRelatorio.id == img["id"]).first()
                    if existente:
                        existente.categoria = img.get("categoria")
                        existente.local = img.get("local")
                        existente.legenda = img.get("legenda")

        db.commit()
        return {"message": "AutoSave executado com sucesso", "relatorio_id": relatorio_id}

    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Erro no AutoSave: {str(e)}")

üß≠ Frontend ‚Äì Comportamento do AutoSave

O frontend deve monitorar altera√ß√µes em qualquer campo do relat√≥rio, incluindo uploads e exclus√µes de imagens.

Sempre que uma altera√ß√£o ocorrer, deve atualizar o estado alteracoesPendentes = true.

A cada 5 segundos, o sistema verifica se h√° altera√ß√µes pendentes e envia uma requisi√ß√£o POST /api/relatorios/autosave com todos os dados atuais do formul√°rio.

Exemplo (React ou Flet com useEffect equivalente):