Corre√ß√£o de Duplica√ß√£o de Imagens e Envio de E-mails

‚öôÔ∏è Instru√ß√µes t√©cnicas:
Reescreva e otimize completamente as fun√ß√µes respons√°veis por:

Concluir relat√≥rio

Aprovar relat√≥rio (e enviar e-mail)

Implementando as corre√ß√µes abaixo, sem alterar a estrutura geral do banco.

üîß 1. Corre√ß√£o do problema de duplica√ß√£o de imagens

Problema identificado:
Ao concluir um relat√≥rio, as imagens associadas est√£o sendo inseridas novamente no banco, gerando duplica√ß√µes no diret√≥rio e na tabela foto_relatorio.

Corre√ß√£o esperada:

Antes de salvar novas imagens, verificar se o arquivo (ou registro) j√° existe no banco com base em relatorio_id e nome_arquivo.

Impedir reupload do mesmo arquivo.

Substituir apenas se for uma atualiza√ß√£o de legenda, categoria ou local.

Implementa√ß√£o t√©cnica:

# Dentro da fun√ß√£o de conclus√£o do relat√≥rio
for foto_data in imagens_recebidas:
    nome_arquivo = foto_data.get("filename")
    legenda = foto_data.get("legenda")
    categoria = foto_data.get("categoria")
    local = foto_data.get("local")

    # Verificar se a imagem j√° existe
    foto_existente = FotoRelatorio.query.filter_by(
        relatorio_id=relatorio.id,
        nome_arquivo=nome_arquivo
    ).first()

    if foto_existente:
        # Atualiza dados se necess√°rio (sem duplicar)
        foto_existente.legenda = legenda
        foto_existente.categoria = categoria
        foto_existente.local = local
        db.session.add(foto_existente)
        app.logger.info(f"üñºÔ∏è Atualizada imagem existente: {nome_arquivo}")
    else:
        # Adiciona nova imagem apenas se n√£o existir
        nova_foto = FotoRelatorio(
            relatorio_id=relatorio.id,
            nome_arquivo=nome_arquivo,
            legenda=legenda,
            categoria=categoria,
            local=local
        )
        db.session.add(nova_foto)
        app.logger.info(f"üÜï Nova imagem adicionada: {nome_arquivo}")

db.session.commit()
app.logger.info(f"‚úÖ Imagens processadas sem duplica√ß√µes para relat√≥rio {relatorio.id}")


üß© Garantias t√©cnicas:

O campo relatorio_id + nome_arquivo deve ser √∫nico (se necess√°rio, aplicar uma constraint no banco).

Logs detalham se a imagem foi ‚ÄúAtualizada‚Äù ou ‚ÄúNova‚Äù.

üìß 2. Corre√ß√£o do erro no envio de e-mail ao aprovar relat√≥rio

Problema identificado:
O erro ocorre por falha na autentica√ß√£o SMTP, manipula√ß√£o incorreta do anexo ou m√° serializa√ß√£o dos destinat√°rios.

Corre√ß√£o esperada:

Garantir conex√£o SMTP v√°lida e reutiliz√°vel.

Corrigir encoding do PDF e garantir que o arquivo existe.

Corrigir l√≥gica de destinat√°rios (sem duplicar, sem ‚ÄúNone‚Äù).

Garantir envio para todos os envolvidos sem crashar a rota.

Implementa√ß√£o t√©cnica:

import smtplib
from email.message import EmailMessage
from models import Relatorio, FotoRelatorio, Projeto, User
import os

def send_report_approval_email(relatorio_id):
    relatorio = Relatorio.query.get(relatorio_id)
    if not relatorio:
        app.logger.error(f"‚ùå Relat√≥rio {relatorio_id} n√£o encontrado para envio de e-mail.")
        return False

    projeto = relatorio.projeto
    responsavel_email = getattr(relatorio.autor, "email", None)
    destinatarios = set()

    # Adiciona todos os envolvidos
    if responsavel_email:
        destinatarios.add(responsavel_email)
    if projeto and projeto.responsavel and projeto.responsavel.email:
        destinatarios.add(projeto.responsavel.email)
    for a in relatorio.acompanhantes:
        if a.email:
            destinatarios.add(a.email)
    if projeto and hasattr(projeto, "funcionarios"):
        for f in projeto.funcionarios:
            if f.email:
                destinatarios.add(f.email)

    # Verifica√ß√£o do anexo PDF
    pdf_path = f"/app/reports/RELATORIO-{relatorio.id}.pdf"
    if not os.path.exists(pdf_path):
        app.logger.warning(f"‚ö†Ô∏è PDF n√£o encontrado para relat√≥rio {relatorio.id}. Gerando novo arquivo...")
        gerar_pdf_relatorio(relatorio.id)  # Fun√ß√£o existente de gera√ß√£o de PDF

    try:
        msg = EmailMessage()
        msg["From"] = "relatorios@elpconsultoria.eng.br"
        msg["Subject"] = f"RELATORIO-{relatorio.numero}"
        msg.set_content(f"""
Este √© o relat√≥rio da obra "{projeto.nome}".
Qualquer d√∫vida, entre em contato com {responsavel_email}.
        """)

        # Anexa PDF
        with open(pdf_path, "rb") as pdf:
            msg.add_attachment(
                pdf.read(),
                maintype="application",
                subtype="pdf",
                filename=f"RELATORIO-{relatorio.numero}.pdf"
            )

        with smtplib.SMTP("smtp.gmail.com", 587) as smtp:
            smtp.starttls()
            smtp.login("relatorios@elpconsultoria.eng.br", "ugZ32b9ayCgu5uK=")
            for email_destino in destinatarios:
                msg["To"] = email_destino
                smtp.send_message(msg)
                app.logger.info(f"üì® E-mail enviado para {email_destino}")

        app.logger.info(f"‚úÖ Todos os e-mails enviados com sucesso ({len(destinatarios)} destinat√°rios).")
        return True

    except Exception as e:
        app.logger.error(f"‚ùå Falha ao enviar e-mails do relat√≥rio {relatorio_id}: {str(e)}")
        return False

üß© 3. Integra√ß√£o final

Dentro da rota /api/relatorios/<id>/concluir:

processar_imagens(relatorio_id)
send_report_approval_email(relatorio_id)

‚úÖ Resultado esperado

Nenhuma imagem √© duplicada no banco ou no diret√≥rio.

Legendas e categorias continuam associadas corretamente.

Ao aprovar um relat√≥rio:

Todos os destinat√°rios recebem o e-mail com o PDF anexo.

Nenhum erro de SMTP, encoding ou destinat√°rio ausente.

Logs mostram todos os destinat√°rios e status de envio.