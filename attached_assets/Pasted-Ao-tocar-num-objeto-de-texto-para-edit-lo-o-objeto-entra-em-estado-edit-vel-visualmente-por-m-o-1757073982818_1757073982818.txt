Ao tocar num objeto de texto para editá-lo, o objeto entra em estado editável (visualmente), porém o teclado virtual não abre no iOS/Android — o usuário não consegue digitar.

Hipóteses comuns (o que normalmente causa isso)

O input/textarea usado para edição não está sendo inserido no DOM visível ou não recebe focus() de forma que o SO permita abrir o teclado.

Foco é chamado de forma assíncrona fora do contexto de gesto do usuário (alguns navegadores bloqueiam foco se não estiver associado a um evento de usuário).

Listeners de touch/canvas estão chamando event.preventDefault() ou usando listeners não-passivos que impedem o comportamento nativo.

A biblioteca de edição (p.ex. Fabric.js) não cria corretamente o overlay de input no mobile ou existe um overlay CSS que impede foco.

Requisito

Garantir que ao tocar no texto no mobile o teclado nativo abra sempre e o usuário consiga editar normalmente, tanto no Novo Relatório quanto no Novo Relatório Express.

Solução recomendada (Fabric.js — implementação robusta)

Abordagem preferida: criar um textarea/input nativo posicionado sobre o canvas no local do texto quando o usuário iniciar edição, inserir no DOM e garantir focus() no mesmo ciclo de evento do toque (síncrono ou em touchend). Ao concluir (blur / Enter), salvar o texto de volta no objeto Fabric e remover o input.

Exemplo (pseudocódigo / orientação para implementação):

// handler ao tocar no objeto de texto
canvas.on('mouse:down', function(opt) {
  const target = opt.target;
  if (!target || !target.isType || !target.isType('i-text') && !target.isType('textbox')) return;

  // calcula posição em pixels na tela
  const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();
  const bound = target.getBoundingRect(true, true);

  // cria textarea nativo
  const ta = document.createElement('textarea');
  ta.value = target.text || '';
  ta.style.position = 'absolute';
  ta.style.left  = `${canvasRect.left + bound.left}px`;
  ta.style.top   = `${canvasRect.top + bound.top}px`;
  ta.style.width = `${Math.max(60, bound.width)}px`;
  ta.style.height = `${Math.max(30, bound.height)}px`;
  ta.style.font = `${target.fontSize}px ${target.fontFamily}`;
  ta.style.zIndex = 9999;
  ta.setAttribute('inputmode', 'text');
  ta.setAttribute('autocapitalize', 'sentences');

  document.body.appendChild(ta);

  // foco: importante tentar focar dentro do mesmo evento de toque, preferencialmente em touchend
  // Se necessário, chame focus() no touchend para garantir que SO permita abrir teclado.
  ta.focus();

  // Ao sair do textarea, aplica no objeto e remove overlay
  ta.addEventListener('blur', () => {
    target.text = ta.value;
    canvas.requestRenderAll();
    ta.remove();
  });

  // também atenda Enter/Escape se fizer sentido
  ta.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      ta.blur();
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      ta.remove();
      canvas.requestRenderAll();
    }
  });
});


Observações técnicas e cuidados

Chamar focus() do input preferencialmente em resposta direta ao evento de toque/tap do usuário (ex.: no touchend do canvas.wrapperEl) para evitar bloqueio do teclado por política do browser. Se for preciso adiar, usar requestAnimationFrame ou setTimeout(…, 0) com testes em iOS.

Ajustar textarea para inputmode="text" e definir autocorrect, autocapitalize conforme necessário.

Garantir que nenhum preventDefault() esteja bloqueando a abertura do teclado. Remover preventDefault() em handlers cuja função não exija isso durante a edição de texto.

Remover pointer-events: none ou overlays que possam impedir foco.

No CSS, garantir que -webkit-user-modify: read-write-plaintext-only; não esteja bloqueando.

Testar em dispositivos reais (iOS Safari, Chrome Android) — foco em iOS, que costuma ser mais restritivo.