Prompt t√©cnico profissional para corre√ß√£o completa do upload autom√°tico de imagens (AutoSave)

Corrigir completamente o comportamento do AutoSave em rela√ß√£o ao envio de imagens durante a cria√ß√£o e edi√ß√£o de relat√≥rios.

Problema identificado:

O AutoSave tenta enviar a imagem imediatamente ap√≥s o upload, antes de o campo de legenda (ou outros metadados) serem preenchidos.

Isso faz com que a API /api/uploads/temp retorne erro 400 - CSRF token missing.

O erro ocorre porque a requisi√ß√£o √© enviada fora do contexto autenticado do formul√°rio e sem os metadados esperados.

Objetivo da corre√ß√£o:

Impedir o envio autom√°tico da imagem enquanto o campo de legenda (ou categoria/local) estiver vazio.

Garantir que o CSRF token (ou cabe√ßalho de autentica√ß√£o equivalente) seja inclu√≠do em toda requisi√ß√£o ao endpoint /api/uploads/temp.

Aguardar o preenchimento completo da legenda antes de efetuar o upload, e apenas ent√£o permitir que o AutoSave processe a imagem.

Evitar erro 400 (Bad Request) e upload redundante, garantindo o comportamento suave e consistente entre desktop e mobile.

O sistema est√° deployado no Railway com FastAPI e PostgreSQL, e j√° possui suporte a upload multipart/form-data.

üß© Frontend (JS ‚Äì reports_autosave.js)
‚úÖ 1Ô∏è‚É£ Adicionar controle de bloqueio de upload at√© legenda ser preenchida
async uploadImageTemp(image) {
  try {
    // üîí Verifica se a legenda foi preenchida antes de enviar
    if (!image.caption || image.caption.trim() === "") {
      console.warn(`‚è∏Ô∏è Upload adiado: legenda ainda n√£o preenchida para ${image.name}`);
      // Reagenda o upload para daqui 2 segundos
      setTimeout(() => this.uploadImageTemp(image), 2000);
      return null;
    }

    console.log(`üì§ AutoSave - Preparando upload da imagem: ${image.name}`);

    const formData = new FormData();
    formData.append("file", image.blob, image.name);
    formData.append("caption", image.caption);
    formData.append("category", image.category || "");
    formData.append("local", image.local || "");

    // üîê Inclui CSRF token se necess√°rio
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || "";
    const headers = csrfToken ? { "X-CSRFToken": csrfToken } : {};

    const response = await fetch("/api/uploads/temp", {
      method: "POST",
      headers,
      body: formData,
      credentials: "include", // üîê importante para cookies de sess√£o
    });

    if (!response.ok) throw new Error(`Upload falhou: ${response.status}`);

    const data = await response.json();
    console.log("‚úÖ Upload tempor√°rio bem-sucedido:", data);
    return data.temp_id || data.id || null;
  } catch (err) {
    console.error("‚ùå Erro no upload tempor√°rio:", err);
    throw err;
  }
}

‚úÖ 2Ô∏è‚É£ Garantir que a imagem seja armazenada com a legenda antes do upload
// Quando o usu√°rio digitar a legenda, atualizar o objeto da imagem no mobilePhotoData
function handleCaptionChange(imageId, newCaption) {
  const img = window.mobilePhotoData?.find(i => i.id === imageId);
  if (img) {
    img.caption = newCaption;
    console.log(`‚úèÔ∏è Legenda atualizada para ${img.name}: "${newCaption}"`);
  }
}


Esse handler deve ser chamado pelo campo de input da legenda:

<input type="text" oninput="handleCaptionChange('mobile_photo_1', this.value)">

‚úÖ 3Ô∏è‚É£ Prevenir AutoSave de disparar imediatamente ap√≥s upload

Adicione uma condi√ß√£o no in√≠cio do performSave():

async performSave() {
  // Evita salvar se existir imagem sem legenda
  const pendingImages = (window.mobilePhotoData || []).filter(
    img => img.blob && (!img.caption || img.caption.trim() === "")
  );

  if (pendingImages.length > 0) {
    console.warn("‚è∏Ô∏è AutoSave adiado: h√° imagens sem legenda.");
    return;
  }

  // ... restante do AutoSave
}

üß† Backend (FastAPI)

Verifique se o endpoint /api/uploads/temp aceita autentica√ß√£o via cookie/session:

@router.post("/uploads/temp")
async def upload_temp_image(
    file: UploadFile = File(...),
    caption: str = Form(""),
    category: str = Form(""),
    local: str = Form(""),
    request: Request = None
):
    # Verifica√ß√£o opcional de CSRF se o frontend enviar token
    csrf_token = request.headers.get("x-csrftoken")
    if not csrf_token and "session" in request.cookies:
        # Permite caso a sess√£o esteja v√°lida
        pass

    # Salva a imagem localmente
    filename = f"{uuid.uuid4()}_{file.filename}"
    with open(f"temp/{filename}", "wb") as buffer:
        buffer.write(await file.read())

    return {
        "success": True,
        "filename": file.filename,
        "path": f"temp/{filename}",
        "caption": caption,
        "category": category,
        "local": local,
        "temp_id": str(uuid.uuid4()),
    }

‚úÖ Resultado Esperado

Ap√≥s aplicar o prompt:

O AutoSave n√£o tentar√° salvar imagens sem legenda.

O upload ser√° feito somente ap√≥s o preenchimento completo dos campos obrigat√≥rios.

Nenhum erro 400 Bad Request ou CSRF token missing.

Logs esperados:

üì∏ Imagem 0: Captura de tela 2025-11-02 172409.png
‚è∏Ô∏è Upload adiado: legenda ainda n√£o preenchida
‚úèÔ∏è Legenda atualizada para Captura de tela 2025-11-02 172409.png: "Inspe√ß√£o final da parede norte"
üì§ AutoSave - Preparando upload da imagem: Captura de tela 2025-11-02 172409.png
‚úÖ Upload tempor√°rio bem-sucedido: { temp_id: "...", caption: "Inspe√ß√£o final da parede norte" }
