Prompt Profissional ‚Äî Corre√ß√£o Definitiva do AutoSave para salvar corretamente as imagens no relat√≥rio

Corrigir completamente o fluxo de AutoSave dos relat√≥rios, garantindo que:

As imagens mapeadas no frontend sejam efetivamente salvas no banco via API /api/relatorios/autosave.

Todas as imagens associadas ao relat√≥rio sejam persistidas na tabela foto_relatorio (ou equivalente).

A resposta da API retorne corretamente as imagens associadas ao relat√≥rio salvo.

O processo funcione tanto em edi√ß√£o quanto cria√ß√£o de relat√≥rios, sem duplicar registros.

A tabela legendas_predefinidas j√° existe e n√£o est√° relacionada com o problema.

üß© 1Ô∏è‚É£ FRONTEND ‚Äî reports_autosave.js
üîß Ajustar coleta de imagens e envio no corpo da requisi√ß√£o
async performSave() {
  try {
    console.log("üìã AutoSave - Checklist:", this.checklist);
    console.log("üì∏ AutoSave - Total de fotos:", this.photos.length);

    // üîç Garante que todas as imagens tenham dados consistentes
    const preparedPhotos = this.photos
      .filter(photo => photo && photo.name)
      .map(photo => ({
        id: photo.id || null,
        filename: photo.name,
        caption: photo.caption || "",
        category: photo.category || "",
        local: photo.local || "",
        path: photo.path || photo.previewUrl || "",
        temp_id: photo.temp_id || null,
      }));

    console.log("üì¶ AutoSave - Dados coletados (com imagens):", {
      ...this.currentReportData,
      fotos: preparedPhotos,
    });

    const payload = {
      ...this.currentReportData,
      fotos: preparedPhotos, // üî• Envia as imagens diretamente
      checklist_data: this.checklist || [],
      acompanhantes: this.acompanhantes || [],
    };

    const response = await fetch("/api/relatorios/autosave", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
      credentials: "include",
    });

    if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
    const result = await response.json();

    console.log("‚úÖ AutoSave conclu√≠do com sucesso:", result);

    // üîÅ Atualiza o estado local com as imagens retornadas
    if (result.imagens && result.imagens.length > 0) {
      console.log(`üì∏ AutoSave: ${result.imagens.length} imagens persistidas.`);
      this.photos = result.imagens;
    } else {
      console.warn("‚ö†Ô∏è AutoSave: Nenhuma imagem retornada pela API.");
    }

    console.log("‚úÖ AutoSave FINAL:", this.photos.length, "imagens processadas");
  } catch (err) {
    console.error("‚ùå AutoSave falhou:", err);
  }
}

üß† 2Ô∏è‚É£ BACKEND ‚Äî FastAPI
üîß Atualizar endpoint /api/relatorios/autosave
@router.post("/relatorios/autosave")
async def autosave_relatorio(request: Request, db: Session = Depends(get_db)):
    """
    Salva automaticamente os dados do relat√≥rio, incluindo imagens, checklist e acompanhantes.
    """
    data = await request.json()
    relatorio_id = data.get("id")
    fotos = data.get("fotos", [])
    
    # üîç Busca ou cria o relat√≥rio
    relatorio = db.query(Relatorio).filter_by(id=relatorio_id).first()
    if not relatorio:
        relatorio = Relatorio()
        db.add(relatorio)
    
    # üîÑ Atualiza campos principais
    for field in [
        "titulo", "numero", "data_relatorio", "observacoes_finais",
        "lembrete_proxima_visita", "projeto_id", "conteudo", "status"
    ]:
        if field in data:
            setattr(relatorio, field, data[field])

    db.commit()
    db.refresh(relatorio)

    # üîÅ Atualiza ou cria imagens associadas
    for foto in fotos:
        if not foto.get("filename"):
            continue
        existente = (
            db.query(FotoRelatorio)
            .filter_by(relatorio_id=relatorio.id, filename=foto["filename"])
            .first()
        )
        if not existente:
            nova_foto = FotoRelatorio(
                relatorio_id=relatorio.id,
                filename=foto["filename"],
                caption=foto.get("caption", ""),
                category=foto.get("category", ""),
                local=foto.get("local", ""),
                path=foto.get("path", ""),
            )
            db.add(nova_foto)
        else:
            existente.caption = foto.get("caption", existente.caption)
            existente.local = foto.get("local", existente.local)
            existente.category = foto.get("category", existente.category)
            existente.path = foto.get("path", existente.path)
    
    db.commit()

    imagens_salvas = (
        db.query(FotoRelatorio)
        .filter_by(relatorio_id=relatorio.id)
        .order_by(FotoRelatorio.id.asc())
        .all()
    )

    return {
        "success": True,
        "message": "AutoSave executado com sucesso",
        "relatorio_id": relatorio.id,
        "relatorio": relatorio.to_dict(),
        "imagens": [img.to_dict() for img in imagens_salvas],
    }

üß© 3Ô∏è‚É£ MODEL ‚Äî Estrutura das tabelas
relatorios
CREATE TABLE IF NOT EXISTS relatorios (
    id SERIAL PRIMARY KEY,
    numero VARCHAR(50),
    titulo VARCHAR(255),
    projeto_id INTEGER REFERENCES projetos(id),
    data_relatorio DATE,
    observacoes_finais TEXT,
    lembrete_proxima_visita TIMESTAMP NULL,
    conteudo TEXT,
    status VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

foto_relatorio
CREATE TABLE IF NOT EXISTS foto_relatorio (
    id SERIAL PRIMARY KEY,
    relatorio_id INTEGER REFERENCES relatorios(id) ON DELETE CASCADE,
    filename VARCHAR(255) NOT NULL,
    caption TEXT,
    category VARCHAR(100),
    local VARCHAR(100),
    path TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

‚úÖ Resultado Esperado

Ap√≥s o ajuste:

Logs do AutoSave devem indicar:

üì∏ AutoSave - Total de fotos: 2
üì§ AutoSave: Enviando dados...
‚úÖ AutoSave conclu√≠do com sucesso: { imagens: [ {...}, {...} ] }
üì∏ AutoSave: 2 imagens persistidas.
‚úÖ AutoSave FINAL: 2 imagens processadas


A tabela foto_relatorio deve exibir corretamente as imagens vinculadas a relatorio_id.