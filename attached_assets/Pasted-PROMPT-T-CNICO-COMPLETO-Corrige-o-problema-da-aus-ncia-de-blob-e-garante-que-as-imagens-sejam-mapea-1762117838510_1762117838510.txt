PROMPT T√âCNICO COMPLETO

Corrige o problema da aus√™ncia de blob e garante que as imagens sejam mapeadas e enviadas corretamente no AutoSave, mantendo compatibilidade com o Railway e FastAPI.

‚öôÔ∏è Prompt

Corrigir completamente a l√≥gica de captura, mapeamento e upload de imagens no AutoSave.
O problema atual √© que as imagens aparecem no mobilePhotoData, mas n√£o possuem o blob associado, gerando o erro:
‚ö†Ô∏è Imagem inv√°lida ou blob ausente.

A corre√ß√£o deve garantir que cada imagem capturada pela c√¢mera ou carregada da galeria tenha seu File/Blob armazenado corretamente e seja enviada ao backend via multipart/form-data no AutoSave.

O sistema est√° hospedado no Railway, com backend em FastAPI e banco PostgreSQL.
A tabela legendas_predefinidas j√° existe e n√£o est√° relacionada ao erro atual.

üß© Implementa√ß√µes obrigat√≥rias no frontend (reports_autosave.js)
1Ô∏è‚É£ Armazenar o blob ao capturar imagens

Substituir o c√≥digo que processa as fotos (no trecho de c√¢mera/galeria) por:

// Executado quando o usu√°rio captura ou seleciona uma imagem
function handleImageCapture(file) {
  const imageObj = {
    id: `mobile_photo_${Date.now()}`,
    name: file.name,
    blob: file, // üî• salva o blob real
    previewUrl: URL.createObjectURL(file),
    category: "",
    local: "",
    caption: "",
    savedId: null,
    temp_id: null,
    hasFile: true,
  };

  if (!window.mobilePhotoData) window.mobilePhotoData = [];
  window.mobilePhotoData.push(imageObj);

  console.log("üì∏ Imagem capturada e registrada com blob:", imageObj);
}


Explica√ß√£o:
Antes, o sistema armazenava apenas previewUrl. Agora o objeto cont√©m o blob necess√°rio para upload real.

2Ô∏è‚É£ Corrigir getImageData() para validar e enviar apenas imagens com blob
async getImageData() {
  const imgs = window.mobilePhotoData || [];
  const uploaded = [];

  for (let i = 0; i < imgs.length; i++) {
    const img = imgs[i];
    console.log(`üì∏ Imagem ${i}:`, img);

    if (!img || !img.blob) {
      console.warn("‚ö†Ô∏è Imagem inv√°lida ou blob ausente:", img);
      continue; // ignora sem travar
    }

    try {
      const tempId = await this.uploadImageTemp(img);
      uploaded.push({
        temp_id: tempId,
        filename: img.name,
        category: img.category,
        local: img.local,
        caption: img.caption,
      });
    } catch (err) {
      console.error(`‚ùå Falha ao enviar imagem ${i}:`, err);
    }
  }

  console.log(`üì∏ AutoSave - Total de ${uploaded.length} imagens enviadas`);
  return uploaded;
}

3Ô∏è‚É£ Reimplementar uploadImageTemp() para envio correto via multipart/form-data
async uploadImageTemp(image) {
  try {
    const formData = new FormData();
    formData.append("file", image.blob, image.name);
    formData.append("category", image.category || "");
    formData.append("local", image.local || "");
    formData.append("caption", image.caption || "");

    const response = await fetch("https://elpconsultoria.pro/api/uploads/temp", {
      method: "POST",
      body: formData,
    });

    if (!response.ok) throw new Error(`Upload falhou: ${response.status}`);

    const data = await response.json();
    console.log("‚úÖ Upload tempor√°rio bem-sucedido:", data);
    return data.temp_id || data.id || null;
  } catch (err) {
    console.error("‚ùå Erro no upload tempor√°rio:", err);
    throw err;
  }
}

üß± Backend (FastAPI / Railway)

O endpoint /api/uploads/temp deve aceitar arquivos corretamente:

@router.post("/uploads/temp")
async def upload_temp_image(
    file: UploadFile = File(...),
    category: str = Form(""),
    local: str = Form(""),
    caption: str = Form("")
):
    try:
        file_path = f"temp/{uuid.uuid4()}_{file.filename}"
        with open(file_path, "wb") as buffer:
            buffer.write(await file.read())

        return {
            "success": True,
            "temp_id": str(uuid.uuid4()),
            "filename": file.filename,
            "path": file_path,
            "category": category,
            "local": local,
            "caption": caption,
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro ao salvar arquivo: {e}")

üß† Resultado Esperado

Ap√≥s a corre√ß√£o:

‚úÖ mobilePhotoData conter√° o campo blob corretamente.

‚úÖ getImageData() enviar√° o arquivo real ao backend.

‚úÖ Logs no console:

üì∏ Imagem 0: Captura de tela 2025-11-02 172409.png
üì§ Upload tempor√°rio bem-sucedido: { temp_id: '...', filename: 'Captura de tela 2025-11-02 172409.png' }
üì∏ AutoSave - Total de 2 imagens enviadas


‚úÖ Nenhum erro ‚ÄúImagem inv√°lida ou blob ausente‚Äù.

‚úÖ AutoSave incluir√° corretamente imagens + checklist + acompanhantes.